#!/usr/bin/env bash

get_lines() {
    # Work out if we're referencing 0, 1, or 2 lines in a file
    if [[ -n $line2 ]]; then
        line=${fileRange}
    elif [[ -n $line1 ]]; then
        line=${fileLine}
    else
        line=''
    fi
    echo "$line"
}

remote_github() {
    domain=${domain:-github.com}
    repo=${repoBase}/${repoPath}
    fileLine=#L${line1}
    fileRange=#L${line1}-L${line2}
    line=$(get_lines) # Leave this as is
    url_repository=https://${domain}/${repo}
    url_branches=${url_repository}/branches
    url_branch=${url_repository}/tree/${branch}
    url_commit=${url_repository}/commit/${commit_hash}
    url_compare=${url_repository}/compare/${commit_hash}${notation}${compare_hash}
    url_fileInBranch=${url_repository}/blob/${branch}/${filename}${line}
    url_fileInCommit=${url_repository}/blob/${commit_hash}/${filename}${line}
    url_file="${url_repository}?path=${filename}${line}"
}

remote_gitlab() {
    domain=${domain:-gitlab.com}
    repo=${repoBase}/${repoPath}
    fileLine=#L${line1}
    fileRange=#L${line1}-${line2}
    line=$(get_lines) # Leave this as is
    url_repository=https://${domain}/${repo}
    url_branches=${url_repository}/-/branches
    url_branch=${url_repository}/-/tree/${branch}
    url_commit=${url_repository}/-/commit/${commit_hash}
    url_compare=${url_repository}/-/compare/${commit_hash}${notation}${compare_hash}
    url_fileInBranch=${url_repository}/-/blob/${branch}/${filename}${line}
    url_fileInCommit=${url_repository}/-/blob/${commit_hash}/${filename}${line}
    url_file="${url_repository}?path=${filename}${line}"
}

remote_bitbucket() {
    domain=${domain:-bitbucket.com}
    repo=${repoBase}/${repoPath}
    fileLine=#${filename}-${line1}
    fileRange=#${filename}-${line1}:${line2}
    line=$(get_lines) # Leave this as is
    url_repository=https://${domain}/${repo}
    url_branches=${url_repository}/branches
    url_branch=${url_repository}/branch/${branch}
    url_commit=${url_repository}/commits/${commit_hash}
    url_compare=${url_repository}/${commit_hash}%0D${compare_hash}
    url_compare=${url_compare//%250D/%0D}
    url_fileInBranch=${url_repository}/src/${branch}/${filename}${line}
    url_fileInCommit=${url_repository}/src/${commit_hash}/${filename}${line}
    url_file="${url_repository}?path=${filename}${line}"
}

remote_gitea() {
    domain=${domain:-gitea.com}
    repo=${repoBase}/${repoPath}
    fileLine=#L${line1}
    fileRange=#L${line1}-L${line2}
    line=$(get_lines) # Leave this as is
    url_repository=https://${domain}/${repo}
    url_branches=${url_repository}/branches
    url_branch=${url_repository}/src/branch/${branch}
    url_commit=${url_repository}/commit/${commit_hash}
    url_compare=${url_repository}/compare/${commit_hash}...${compare_hash}
    url_fileInBranch=${url_repository}/src/branch/${branch}/${filename}${line}
    url_fileInCommit=${url_repository}/src/commit/${commit_hash}/${filename}${line}
    url_file=${url_repository}/src/${filename}${line}
}
remote_forgejo() {
    remote_gitea
}
remote_codeberg() {
    domain=codeberg.org
    remote_gitea
}

remote_klaus() {
    #domain=${domain}
    repo=${repoBase}/${repoPath}
    fileLine=#L-${line1}
    fileRange=$fileLine
    line=$(get_lines) # Leave this as is
    url_repository=https://${domain}/${repo}
    url_branches=''
    url_branch="${url_repository}/${branch}?path="
    url_commit=${url_repository}/commit/${commit_hash}/
    url_compare=''
    url_fileInBranch=${url_repository}/blob/${branch}/${filename}${line}
    url_fileInCommit=${url_repository}/blob/${commit_hash}/${filename}${line}
    url_file=''
}

remote_gitit() {
    #domain=${domain}
    repo=${repoBase}/${repoPath}
    fileLine=#L-${line1}
    fileRange=$fileLine
    line=$(get_lines) # Leave this as is
    url_repository=https://${domain}/${repo}
    url_branches=''
    url_branch=''
    url_commit=''
    url_compare="${url_repository}/_diff/${filename%.page}?from=${commit_hash}&to=${compare_hash}"
    url_fileInBranch="${url_repository}/${filename%.page}?revision=${commit_hash}"
    url_fileInCommit="${url_repository}/${filename%.page}?revision=${commit_hash}"
    url_file=${url_repository}/${filename%.page}
}

# ---------------

remote=${1:-""}
branch=""
filename=${2:-""}
line1=${3:-""}
line2=${4:-""}

# get remote name
if [[ -z $remote ]]; then
    branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null)"
    remote=$(git config branch."${branch}".remote ||
        git remote | grep -w origin ||
        git remote | head -1)
fi

if [[ -z $remote ]]; then
    echo "Remote not found"
    exit 1
fi

remote_url=$(git remote get-url "$remote") || exit $?

if [[ $remote_url = git@* ]]; then
    url=$(echo "$remote_url" | sed -E -e 's/:/\//' -e 's/\.git$//' -e 's/.*@(.*)/\1/')
elif [[ $remote_url = ssh://* ]]; then
    url=$(echo "$remote_url" | sed -E -e 's/ssh:\/\///' -e 's/\.git$//' -e 's/:[[:digit:]]*//' -e 's/.*@(.*)/\1/')
elif [[ $remote_url = http* ]]; then
    url=${remote_url%.git}
# FIXME: This regex should say "a colon not followed by two slashes
elif [[ $remote_url =~ .*:.[^/].* ]]; then
    url=$(echo "$remote_url" | sed -E -e 's/:/\//' -e 's/\.git$//' -e 's/(.*@)?(.*)/\2/' -e 's://*:/:g')
fi
IFS=/ read -r domain repoBase repoPath <<<"${url}"

# construct urls
# If "HEAD" was the best abbreviated ref we could find, we don't have a branch/tag name
if [[ $branch = HEAD ]]; then
    branch=''
fi
commit_hash=$(git rev-parse HEAD 2>/dev/null)
commit_or_branch=${commit_hash:-${branch}}

# Check that the commit branch actually *exists* on the remote first:
if ! git branch --remotes --contains "${commit_or_branch}" 2>/dev/null |
    grep -q "\<${remote}\>/"; then
    echo "Commit not yet pushed to remote '${remote}'"
    exit 1
fi

# Ensure filename path is relative to repo root
if [[ -n $filename ]]; then
    filename=$(git ls-files --full-name "${filename}")
fi

compare_hash=''
notation=..

if [[ $remote_url =~ gitlab ]]; then
    remote_gitlab
elif [[ $remote_url =~ github ]]; then
    remote_github
elif [[ $remote_url =~ bitbucket ]]; then
    remote_bitbucket
elif [[ $remote_url =~ bitbucket ]]; then
    remote_bitbucket
elif [[ $remote_url =~ gitea ]]; then
    remote_gitea
elif [[ $remote_url =~ forgejo ]]; then
    remote_forgejo
elif [[ $remote_url =~ codeberg ]]; then
    remote_codeberg
fi

# If we're comparing two refs, we don't care about any referenced files, so
# short-circuit here
if [[ -n $compare_hash ]]; then
    url=$url_compare
else
    if [[ -n $filename ]]; then
        if [[ -n $branch ]]; then
            url=$url_fileInBranch
        elif [[ -n $commit_hash ]]; then
            url=$url_fileInCommit
        else
            url=$url_file
        fi
    else
        if [[ -n $branch ]]; then
            url=$url_branch
        elif [[ -n $commit_hash ]]; then
            url=$url_commit
        else
            url=$url_repository
        fi
    fi
fi
# Remove accidental consecutive slashes from URL
# shellcheck disable=SC2001
url=$(echo "$url" | sed 's://*:/:g')

# If we can't detect one of the major git forges, see if the user has specified
# a URL pattern we can use to construct a URL
# For GitHub, for example, a URL pattern could be set using:
# $ git config --local git-extras.browse-url-pattern "https://github.com/tj/git-extras/blob/{commit_or_branch}/{filename}#L{line1}-L{line2}"
config_pattern() {
    git config --local --get git-extras.browse-url-pattern-"$1"
}
# remote_custom(){
#     # domain=${domain}
#     # repo=${repoBase}/${repoPath}
#     fileLine=#L-${line}
#     fileRange=$fileLine
#     line=$(get_lines) # Leave this as is
#     url_repository=$(config_pattern url_repository)
#     url_branches=
#     url_branch="${url_repository}/${branch}?path="
#     url_commit=${url_repository}/commit/${commit_hash}/
#     url_compare=''
#     url_fileInBranch=${url_repository}/blob/${branch}/${filename}${line}
#     url_fileInCommit=${url_repository}/blob/${commit_hash}/${filename}${line}
#     url_file=''
# }

# open url
case "$OSTYPE" in
darwin*)
    # MacOS
    open "$url"
    ;;
msys)
    # Git-Bash on Windows
    start "$url"
    ;;
linux*)
    # Handle WSL on Windows
    if uname -a | grep -i -q Microsoft && command -v powershell.exe; then
        powershell.exe -NoProfile start "$url"
    else
        xdg-open "$url"
    fi
    ;;
*)
    # fall back to xdg-open for BSDs, etc.
    xdg-open "$url"
    ;;
esac
